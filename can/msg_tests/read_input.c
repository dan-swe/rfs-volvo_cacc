/**\file
 *
 *	Process to read input files generated by input_gen.c
 *	Can be used as a template for more code that does something.
 *	and as an input stream validator to make sure it is formed
 *	correctly.
 *
 *      Copyright (c) 2008 Regents of the University of California
 *
 *	Author: Sue Dickey
 */
#include <sys_os.h>
#include "datastructs.h"
#include "msg_descriptors.h"

static int sig_list[]=
{
	SIGINT,
	SIGQUIT,
	SIGTERM,
	SIGALRM,	// for timer
	(-1)
};
static jmp_buf exit_env;
static void sig_hand(int code)
{
	if (code == SIGALRM)
		return;
	else
		longjmp(exit_env, code);
}

/** Searches the message descriptor array to get the number of
 *  fields for the message type.
 */
int get_index_for_identifier(int identifier)
{
	int i;
	for (i = 0; i < num_message_types; i++) {
		msg_descriptor_t *p = &msg_descriptors[i]; 
		if (p->identifier == identifier)
			return i;
	}
	return -1;	// invalid index returned if not found
}


#define BUFFER_SIZE 1024

int main (int argc, char** argv)
{
	int i, j;
	int opt;
	int verbose = 0;
	char in_buf[BUFFER_SIZE];
	char *ptoken = NULL; 
	int ret;
	int identifier;
	int index;


	while ((opt = getopt(argc, argv, "v")) != -1) {
		switch (opt) {
		case 'v':
			verbose = 1;
			break;
		default:
			printf( "Usage: %s ", argv[0]);
			printf("-v verbose\n");
			exit(1);
		}
	}

	/** Upon signal or jmp from error condition, deactivate if active,
	 *  unregister and close api before exiting.
	 */ 
	if ((ret = setjmp(exit_env)) != 0) {
		fprintf(stderr, "Exiting %s, return value %d\n", argv[0], ret);
		exit(0);
	} else {
                int i = 0;
                while (sig_list[i] != -1) {
                        signal(sig_list[i], sig_hand);
                        i++;
                }
	}

	memset(in_buf, 0, BUFFER_SIZE);
	while (fgets(in_buf, BUFFER_SIZE-1, stdin) != NULL) {
		int num_msgs;	// number of messages on input line
		ptoken = strtok(in_buf, " ");
		if (sscanf(ptoken, " %d ", &num_msgs) <= 0)
			longjmp(exit_env, 1); 
		for (i = 0; i < num_msgs; i++) {
			msg_descriptor_t *p;

			ptoken = strtok(NULL, " ");
			if ((sscanf(ptoken, " %d ", &identifier)) <= 0)
				longjmp(exit_env, 2); 
			if (verbose)
				printf(" %d ", identifier);

			if ((index = get_index_for_identifier(identifier)) < 0)
				longjmp(exit_env, 3);
			p = &msg_descriptors[index];

			fprintf(stderr, "%s\n", p->msg_name);

			for (j = 0; j < p->field_num; j++) {
				int dummy;
				ptoken = strtok(NULL, " ");
				if (sscanf(ptoken, " %d ", &dummy) <= 0)
					longjmp(exit_env, 4); 
				if (verbose) 
					printf(" %d ", dummy);
			} 
		}
	}
	longjmp(exit_env, 5);	 
}

