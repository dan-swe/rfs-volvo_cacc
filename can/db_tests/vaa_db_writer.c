/**\file
 *	Program to write artificial data generated by can/msg_tests/input_gen
 *	into the data server at a frequency specified by command line option.
 *
 *      The specification of how the input line maps into CAN message types
 *	and of the CAN message type being simulated are in the file
 *	can/msg_tests/msg_descriptor.c, which is used by this program as
 *	well as by input_gen and other programs in that directory.	
 *
 *	This program reads the file from stdin until an EOF is encountered.
 *	It waits the specified number of milliseconds before reading
 *	the next line.
 *
 *	Usage: 
 *
 *	vaa_db_writer -i 10	
 *
 *	will write the information read on a line of the file into 
 *	the data server every 10 ms.
 */
#include <sys_os.h>
#include "sys_list.h"
#include "sys_rt.h"
#include "db_clt.h"
#include "db_utils.h"
#include "vaa_clt_vars.h"
#include "vaa_msg.h"

#define BUFFER_SIZE 1024

static void parse_msg_input(unsigned char id, void * dbv);

/** Set up list for signal handling.
 */
static int sig_list[]=
{
        SIGINT,
        SIGQUIT,
        SIGTERM,
        SIGALRM,
        ERROR
};

static jmp_buf exit_env;

static void sig_hand(int code)
{
        if (code == SIGALRM)
                return;
        else
                longjmp(exit_env, code);
}

int main(int argc, char* argv[])
{
	int interval;   	/// milliseconds between reads 
	char line[BUFFER_SIZE];
	int linenum = 0;
	int opt = 0;
	int verbose = 0;

	db_clt_typ *pclt;              /// Database client pointer 
	char hostname[MAXHOSTNAMELEN+1];
	char *domain = DEFAULT_SERVICE;
	int xport = COMM_OS_XPORT;	/// Correct value must be in sys_os.h
	posix_timer_typ *ptimer = NULL;

	// parse the command-line args
	while ((opt = getopt(argc, argv, "i:v")) != -1) {
		switch (opt) {
		case 'i':
			interval = atoi(optarg);
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			printf("Usage: %s -i <interval> -v\n", argv[0]);
			break;
		}
	}

	if ((ptimer = timer_init(interval, ChannelCreate(0))) == NULL) {
                printf("timer_init failed\n");
                exit(EXIT_FAILURE);
        }

        get_local_name(hostname, MAXHOSTNAMELEN);

        /**  assumes DB_COMM variables were aleady created by another process
         */
        pclt = db_list_init(argv[0], hostname, domain, xport, NULL, 0, NULL, 0);

        if( setjmp( exit_env ) != 0 ) {
                db_list_done(pclt, NULL, 0, NULL, 0);
                exit( EXIT_SUCCESS );
        } else
                sig_ign( sig_list, sig_hand );

	while (fgets(line, BUFFER_SIZE-1, stdin) != NULL) {
		int i;
		char *token = strtok(line, " \t");
		int num_of_messages = atoi(token);
		unsigned char id;
		unsigned char db_buffer[MAX_DATA_SIZE];

		if (verbose)
			printf("%d messages per line\n", num_of_messages);

		// Get each message on line and write to data server
		for (i = 0; i < num_of_messages; i++) { 
			token = strtok(NULL, " \t");
			id = atoi(token);

			// parse_msg_input consumes tokens from line
			// based on fields in message with this id
			// fills db_buffer according to message structure
			parse_msg_input(id, &db_buffer[0]);
			db_clt_write(pclt, DB_VAA_BASE+id, 
				vaa_msg[id].size, &db_buffer[0]);

			if (verbose) 
				vaa_msg[id].print(stdout, id,
					&db_buffer[0], vaa_msg[id].size);
		}
		linenum++;
		TIMER_WAIT(ptimer);
	}
	return 0;
}

/// Macro for convenience
#define ITOKEN	atoi(strtok(NULL, " \t"))

/** All fields are an integer type for now.
 *  Later some may be float or double as structures change to match real needs.
 *  Input data would need more complicated generation.
 */
void parse_msg_input(unsigned char id, void *pdbv)
{

	switch (id) {
	case DB_SENSOR_CONFIG_ID:
		{
			sensor_config_t *psc = (sensor_config_t *) pdbv;
			psc->serial =  ITOKEN;
			psc->type = ITOKEN; 
			psc->configuration = ITOKEN; 
		}
		break;
	case DB_SENSOR_STATE_ID:
		{
			sensor_state_t *pss = (sensor_state_t *) pdbv;
			pss->operation_code = ITOKEN; 
			pss->fault_message =  ITOKEN;
			pss->sensor_health[0] =  ITOKEN;
			pss->sensor_health[1] =  ITOKEN;
			pss->sensor_health[2] =  ITOKEN;
			pss->output_type =  ITOKEN;
		}
		break;
	case DB_MESSAGE_STATUS_ID:
		{
			message_status_t *pms = (message_status_t *) pdbv;
			pms->heartbeat =  ITOKEN;
		}
		break;
	case DB_POSITION_NORMAL_ID:
		{
			position_normal_t *ppn = (position_normal_t *) pdbv;
			int k;
			for(k=0; k<6; k++)
			    ppn->lateral_pos[k] =  ITOKEN;
			for(k=0; k<6; k++)
			    ppn->time_stamp[k] =  ITOKEN;
			for(k=0; k<6; k++)
			    ppn->polarity[k] =  ITOKEN;
			for(k=0; k<3; k++)
			    ppn->track_number[k] =  ITOKEN;
	    
			ppn->estimated_speed =  ITOKEN;
			ppn->real_speed =  ITOKEN;
	
			for(k=0; k<3; k++)
			    ppn->missing_magnet_flag[k] =  ITOKEN;
		}
		break;
	case DB_POSITION_RAW_ID:
		{
			position_raw_t *ppr = (position_raw_t *) pdbv;
			int k;
			for(k=0; k<30; k++)
			    ppr->magnetic_strengths[k] = ITOKEN;
			ppr->vehicle_speed =  ITOKEN;
		}
		break;
	case DB_POSITION_CALIBRATION_ID:
		{
			position_calibration_t *ppc = 
						(position_calibration_t *) pdbv;
			int k = 0;
			for(k=0; k<30; k++)
				ppc->magnetic_strengths[k] =  ITOKEN;

		}
		break;
	case DB_CC_STATUS_ID:
		{
			cc_status_t *pccs = (cc_status_t *) pdbv;
			pccs->id =  ITOKEN;
			pccs->status =  ITOKEN;
		}
		break;
	case DB_SYSTEM_COMMAND_ID:
		{
			system_command_t *psc = (system_command_t *) pdbv;
			psc->command =  ITOKEN;
			psc->target =  ITOKEN;
		}
		break;
	case DB_DATA_INPUTS_ID:
		{
			data_inputs_t *pdi = (data_inputs_t *) pdbv;
			pdi->vehicle_speed =  ITOKEN;
			pdi->magnet_information =  ITOKEN;
		}
		break;
	case DB_HMI_STATE_ID:
		{
			hmi_state_t *phs = (hmi_state_t *) pdbv;
			phs->id =  ITOKEN;
			phs->operation_state =  ITOKEN;
			phs->heartbeat =  ITOKEN;
			phs->fault_message =  ITOKEN;
		}
		break;
	case DB_HMI_DEVICE_STATE_ID:
		{
			hmi_device_state_t *phds = (hmi_device_state_t *) pdbv;
			phds->state =  ITOKEN;
			phds->devices =  ITOKEN;
		}
		break;
	case DB_HMI_OPTIONAL_DATA_ID:
		{
			hmi_optional_data_t *phod = (hmi_optional_data_t *)pdbv;
			phod->recommended_action =  ITOKEN;
		}
		break;
	case DB_CC_STATE_ID:
		{
			cc_state_t *pccs = (cc_state_t *) pdbv;
			pccs->id =  ITOKEN;
			pccs->state =  ITOKEN;
			pccs->heartbeat =  ITOKEN;
			pccs->fault_message =  ITOKEN;
		}
		break;
	case DB_CC_OPERATION_STATE_ID:
		{
			cc_operation_state_t *pccos =
					(cc_operation_state_t *) pdbv;
			pccos->controller_state =  ITOKEN;
			pccos->transition_state =  ITOKEN;
			pccos->coordination_state =  ITOKEN;
			pccos->reserved_state =  ITOKEN;
		}
		break;
	case DB_CC_OPTIONAL_DATA_ID:
		{
			cc_optional_data_t *pccod = (cc_optional_data_t *) pdbv;
			pccod->steering_command =  ITOKEN;
		}
		break;
	default:
		fprintf (stderr, "error: unrecognized msg identifer: %d\n",
				 id);
		break;
	}
}
